// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

enum ConnectionManagerState {
  none,
  connecting,
  connected,
  disconnecting,
  disconnected,
}

class NetworkCallLogModel {
  NetworkCallLogModel({
    this.options,
    this.request,
    this.response,
    this.exception,
  });

  Options? options;

  Request? request;

  Response? response;

  ExceptionModel? exception;

  Object encode() {
    return <Object?>[
      options?.encode(),
      request?.encode(),
      response?.encode(),
      exception?.encode(),
    ];
  }

  static NetworkCallLogModel decode(Object result) {
    result as List<Object?>;
    return NetworkCallLogModel(
      options: result[0] != null
          ? Options.decode(result[0]! as List<Object?>)
          : null,
      request: result[1] != null
          ? Request.decode(result[1]! as List<Object?>)
          : null,
      response: result[2] != null
          ? Response.decode(result[2]! as List<Object?>)
          : null,
      exception: result[3] != null
          ? ExceptionModel.decode(result[3]! as List<Object?>)
          : null,
    );
  }
}

class Options {
  Options({
    this.threadName,
    this.connectTimeoutMillis,
    this.readTimeoutMillis,
    this.writeTimeoutMillis,
    this.protocol,
    this.handshake,
  });

  String? threadName;

  int? connectTimeoutMillis;

  int? readTimeoutMillis;

  int? writeTimeoutMillis;

  String? protocol;

  Handshake? handshake;

  Object encode() {
    return <Object?>[
      threadName,
      connectTimeoutMillis,
      readTimeoutMillis,
      writeTimeoutMillis,
      protocol,
      handshake?.encode(),
    ];
  }

  static Options decode(Object result) {
    result as List<Object?>;
    return Options(
      threadName: result[0] as String?,
      connectTimeoutMillis: result[1] as int?,
      readTimeoutMillis: result[2] as int?,
      writeTimeoutMillis: result[3] as int?,
      protocol: result[4] as String?,
      handshake: result[5] != null
          ? Handshake.decode(result[5]! as List<Object?>)
          : null,
    );
  }
}

class Handshake {
  Handshake({
    this.protocolVersion,
    this.cipherSuite,
  });

  String? protocolVersion;

  String? cipherSuite;

  Object encode() {
    return <Object?>[
      protocolVersion,
      cipherSuite,
    ];
  }

  static Handshake decode(Object result) {
    result as List<Object?>;
    return Handshake(
      protocolVersion: result[0] as String?,
      cipherSuite: result[1] as String?,
    );
  }
}

class Request {
  Request({
    required this.method,
    required this.url,
    this.headers,
    required this.timestamp,
    this.contentType,
    this.body,
  });

  String method;

  String url;

  List<Map<String?, String?>?>? headers;

  int timestamp;

  String? contentType;

  String? body;

  Object encode() {
    return <Object?>[
      method,
      url,
      headers,
      timestamp,
      contentType,
      body,
    ];
  }

  static Request decode(Object result) {
    result as List<Object?>;
    return Request(
      method: result[0]! as String,
      url: result[1]! as String,
      headers: (result[2] as List<Object?>?)?.cast<Map<String?, String?>?>(),
      timestamp: result[3]! as int,
      contentType: result[4] as String?,
      body: result[5] as String?,
    );
  }
}

class Response {
  Response({
    this.headers,
    this.statusCode,
    required this.timestamp,
    this.gzippedLength,
    this.length,
    this.contentType,
    this.body,
  });

  List<Map<String?, String?>?>? headers;

  int? statusCode;

  int timestamp;

  int? gzippedLength;

  int? length;

  String? contentType;

  String? body;

  Object encode() {
    return <Object?>[
      headers,
      statusCode,
      timestamp,
      gzippedLength,
      length,
      contentType,
      body,
    ];
  }

  static Response decode(Object result) {
    result as List<Object?>;
    return Response(
      headers: (result[0] as List<Object?>?)?.cast<Map<String?, String?>?>(),
      statusCode: result[1] as int?,
      timestamp: result[2]! as int,
      gzippedLength: result[3] as int?,
      length: result[4] as int?,
      contentType: result[5] as String?,
      body: result[6] as String?,
    );
  }
}

class ExceptionModel {
  ExceptionModel({
    required this.exceptionThreadName,
    required this.crash,
    this.type,
    this.message,
    this.throwableMessage,
    this.data,
    required this.stackTrace,
    this.threads,
  });

  String exceptionThreadName;

  bool crash;

  String? type;

  String? message;

  String? throwableMessage;

  Map<String?, Object?>? data;

  List<ExceptionStacktraceLineModel?> stackTrace;

  Map<String?, List<ExceptionStacktraceLineModel?>?>? threads;

  Object encode() {
    return <Object?>[
      exceptionThreadName,
      crash,
      type,
      message,
      throwableMessage,
      data,
      stackTrace,
      threads,
    ];
  }

  static ExceptionModel decode(Object result) {
    result as List<Object?>;
    return ExceptionModel(
      exceptionThreadName: result[0]! as String,
      crash: result[1]! as bool,
      type: result[2] as String?,
      message: result[3] as String?,
      throwableMessage: result[4] as String?,
      data: (result[5] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
      stackTrace: (result[6] as List<Object?>?)!.cast<ExceptionStacktraceLineModel?>(),
      threads: (result[7] as Map<Object?, Object?>?)?.cast<String?, List<ExceptionStacktraceLineModel?>?>(),
    );
  }
}

class ExceptionStacktraceLineModel {
  ExceptionStacktraceLineModel({
    required this.className,
    this.fileName,
    required this.nativeMethod,
    required this.methodName,
    required this.lineNumber,
  });

  String className;

  String? fileName;

  bool nativeMethod;

  String methodName;

  int lineNumber;

  Object encode() {
    return <Object?>[
      className,
      fileName,
      nativeMethod,
      methodName,
      lineNumber,
    ];
  }

  static ExceptionStacktraceLineModel decode(Object result) {
    result as List<Object?>;
    return ExceptionStacktraceLineModel(
      className: result[0]! as String,
      fileName: result[1] as String?,
      nativeMethod: result[2]! as bool,
      methodName: result[3]! as String,
      lineNumber: result[4]! as int,
    );
  }
}

class _MADAssistantCodec extends StandardMessageCodec {
  const _MADAssistantCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ExceptionModel) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ExceptionStacktraceLineModel) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is Handshake) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is NetworkCallLogModel) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is Options) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is Request) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is Response) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ExceptionModel.decode(readValue(buffer)!);
      case 129: 
        return ExceptionStacktraceLineModel.decode(readValue(buffer)!);
      case 130: 
        return Handshake.decode(readValue(buffer)!);
      case 131: 
        return NetworkCallLogModel.decode(readValue(buffer)!);
      case 132: 
        return Options.decode(readValue(buffer)!);
      case 133: 
        return Request.decode(readValue(buffer)!);
      case 134: 
        return Response.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class MADAssistant {
  /// Constructor for [MADAssistant].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MADAssistant({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MADAssistantCodec();

  /// Initialise a new instance of MADAssistant
  Future<void> init(String arg_passphrase) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.init', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_passphrase]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> connect() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.connect', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> disconnect() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.disconnect', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<ConnectionManagerState> getConnectionState() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.getConnectionState', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return ConnectionManagerState.values[replyList[0]! as int];
    }
  }

  Future<void> startSession() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.startSession', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> endSession() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.endSession', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> hasActiveSession() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.hasActiveSession', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> logCrashes() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.logCrashes', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> logNetworkCall(NetworkCallLogModel arg_data) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.logNetworkCall', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_data]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> logCrashReport(Object arg_throwable, String? arg_message, Map<Object?, Object?>? arg_data) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.logCrashReport', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_throwable, arg_message, arg_data]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> logAnalyticsEvent(String arg_destination, String arg_eventName, Map<Object?, Object?> arg_data) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.logAnalyticsEvent', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_destination, arg_eventName, arg_data]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> logGenericLog(int arg_type, String arg_tag, String arg_message, Map<Object?, Object?>? arg_data) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.logGenericLog', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_type, arg_tag, arg_message, arg_data]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> logException(Object arg_throwable, String? arg_message, Map<String?, dynamic?>? arg_data) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.madassistant.MADAssistant.logException', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_throwable, arg_message, arg_data]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _MADAssistantCallbackCodec extends StandardMessageCodec {
  const _MADAssistantCallbackCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ExceptionModel) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ExceptionStacktraceLineModel) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is Handshake) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is NetworkCallLogModel) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is Options) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is Request) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is Response) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ExceptionModel.decode(readValue(buffer)!);
      case 129: 
        return ExceptionStacktraceLineModel.decode(readValue(buffer)!);
      case 130: 
        return Handshake.decode(readValue(buffer)!);
      case 131: 
        return NetworkCallLogModel.decode(readValue(buffer)!);
      case 132: 
        return Options.decode(readValue(buffer)!);
      case 133: 
        return Request.decode(readValue(buffer)!);
      case 134: 
        return Response.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class MADAssistantCallback {
  static const MessageCodec<Object?> codec = _MADAssistantCallbackCodec();

  void onSessionStarted(int sessionId);

  void onSessionEnded(int sessionId);

  void onConnectionStateChanged(ConnectionManagerState state);

  void onDisconnected(int code, String message);

  void logInfo(String tag, String message);

  void logVerbose(String tag, String message);

  void logDebug(String tag, String message);

  void logWarn(String tag, String message);

  void logError(Object throwable);

  static void setup(MADAssistantCallback? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.onSessionStarted', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onSessionStarted was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_sessionId = (args[0] as int?);
          assert(arg_sessionId != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onSessionStarted was null, expected non-null int.');
          api.onSessionStarted(arg_sessionId!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.onSessionEnded', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onSessionEnded was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_sessionId = (args[0] as int?);
          assert(arg_sessionId != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onSessionEnded was null, expected non-null int.');
          api.onSessionEnded(arg_sessionId!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.onConnectionStateChanged', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onConnectionStateChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ConnectionManagerState? arg_state = args[0] == null ? null : ConnectionManagerState.values[args[0]! as int];
          assert(arg_state != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onConnectionStateChanged was null, expected non-null ConnectionManagerState.');
          api.onConnectionStateChanged(arg_state!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.onDisconnected', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onDisconnected was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_code = (args[0] as int?);
          assert(arg_code != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onDisconnected was null, expected non-null int.');
          final String? arg_message = (args[1] as String?);
          assert(arg_message != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.onDisconnected was null, expected non-null String.');
          api.onDisconnected(arg_code!, arg_message!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.logInfo', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logInfo was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_tag = (args[0] as String?);
          assert(arg_tag != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logInfo was null, expected non-null String.');
          final String? arg_message = (args[1] as String?);
          assert(arg_message != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logInfo was null, expected non-null String.');
          api.logInfo(arg_tag!, arg_message!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.logVerbose', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logVerbose was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_tag = (args[0] as String?);
          assert(arg_tag != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logVerbose was null, expected non-null String.');
          final String? arg_message = (args[1] as String?);
          assert(arg_message != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logVerbose was null, expected non-null String.');
          api.logVerbose(arg_tag!, arg_message!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.logDebug', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logDebug was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_tag = (args[0] as String?);
          assert(arg_tag != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logDebug was null, expected non-null String.');
          final String? arg_message = (args[1] as String?);
          assert(arg_message != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logDebug was null, expected non-null String.');
          api.logDebug(arg_tag!, arg_message!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.logWarn', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logWarn was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_tag = (args[0] as String?);
          assert(arg_tag != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logWarn was null, expected non-null String.');
          final String? arg_message = (args[1] as String?);
          assert(arg_message != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logWarn was null, expected non-null String.');
          api.logWarn(arg_tag!, arg_message!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.madassistant.MADAssistantCallback.logError', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logError was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final Object? arg_throwable = (args[0] as Object?);
          assert(arg_throwable != null,
              'Argument for dev.flutter.pigeon.madassistant.MADAssistantCallback.logError was null, expected non-null Object.');
          api.logError(arg_throwable!);
          return;
        });
      }
    }
  }
}
